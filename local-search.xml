<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>别让副作用“爆炸”你的代码！——一次CR后的深度反思</title>
    <link href="/2025/05/19/side-effect/"/>
    <url>/2025/05/19/side-effect/</url>
    
    <content type="html"><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>笔者下午在code review一个新手的代码时 发现了一个<strong>几乎每个新手都会踩的坑</strong>:</p><blockquote><p>他把一个表单校验的副作用函数直接放在了业务核心 reducer 的 action 里</p></blockquote><p>不过情有可原 部门的新手入门一般是<strong>vue</strong> 上手门槛不高 对<strong>reducer side-effect</strong>之类的理解并不深</p><p>笔者有过一段react的开发经验 所以写下了这篇文章 旨在帮助新手朋友们构建更优雅的代码—至少，不能是屎山</p><h1 id="什么是副作用-Side-Effect"><a href="#什么是副作用-Side-Effect" class="headerlink" title="什么是副作用(Side Effect)?"></a>什么是副作用(Side Effect)?</h1><p>笔者刚接触react的时候 也关于这个问题疑虑了好久</p><p>useEffect这个hook让我困惑：</p><blockquote><p>这个东西 究竟要不要放到useEffect里 为什么</p></blockquote><p>然后 我就看到了react官方这么写到</p><blockquote><p><strong>“An Effect lets you keep your component synchronized with some external system (like a chat service).”</strong></p></blockquote><p><a href="https://react.dev/reference/react/useEffect">useEffect – React</a></p><p>这句话说明了<code>useEffect</code> 的作用是让组件与外部系统保持同步，而这些外部系统的交互就是副作用的体现。</p><p>你可能还是觉得“副作用”这个词有点抽象，别急，先看看常见的副作用操作：</p><ul><li><strong>数据获取</strong>：例如，使用 <code>fetch</code> 或 <code>axios</code> 从服务器获取数据。</li><li><strong>订阅和取消订阅</strong>：例如，订阅 WebSocket 或事件总线，并在组件卸载时取消订阅。</li><li><strong>手动操作 DOM</strong>：例如，使用 <code>document.getElementById</code> 或 <code>ref</code> 直接操作 DOM 元素。</li><li><strong>设置定时器</strong>：例如，使用 <code>setTimeout</code> 或 <code>setInterval</code>。</li><li><strong>日志记录</strong>：例如，使用 <code>console.log</code> 或发送日志到服务器。</li></ul><p>看到这里，你对副作用的直观认识应该已经有了雏形。接下来我们来看一下更准确的定义：</p><hr><p><strong>副作用</strong>指的是函数在执行过程中，除了<strong>返回结果</strong>之外，还对<strong>外部状态</strong>产生影响的行为。这些影响包括但不限于：</p><ul><li><strong>修改全局变量</strong>：函数内部改变了全局变量的值。</li><li><strong>进行 I&#x2F;O 操作</strong>：如读取或写入文件、网络请求等。</li><li><strong>操作外部设备</strong>：如打印机、数据库等。</li><li><strong>抛出异常</strong>：函数在执行过程中抛出了异常，影响了程序的控制流。</li></ul><p>这些副作用使得函数的行为不仅仅取决于<strong>输入参数</strong>，还依赖于<strong>外部状态</strong>，从而增加了程序的复杂性。</p><p>与之相对的，我们把<strong>完全不产生副作用的函数</strong>称为<strong>纯函数（Pure Function）</strong>。纯函数始终对同样的输入产生同样的输出，不依赖也不影响外部状态——这也是函数式编程中的核心理念之一。</p><hr><p>写到这里，相信你已经对副作用的本质有了更清晰的理解。</p><h1 id="为什么要分离副作用？"><a href="#为什么要分离副作用？" class="headerlink" title="为什么要分离副作用？"></a>为什么要分离副作用？</h1><h2 id="副作用混进主逻辑的常见后果"><a href="#副作用混进主逻辑的常见后果" class="headerlink" title="副作用混进主逻辑的常见后果"></a>副作用混进主逻辑的常见后果</h2><ul><li>代码将变得难以阅读，如同线缠在一起一般，加大团队协作难度</li><li>测试 debug的成本也会急剧变高 再次加大开发成本</li><li>多次触发副作用可以会导致多次触发、数据不一样</li><li>存在潜在的性能隐患</li></ul><h2 id="分离副作用的好处"><a href="#分离副作用的好处" class="headerlink" title="分离副作用的好处"></a>分离副作用的好处</h2><ul><li>内部逻辑与“对外逻辑”分明 方便协作者阅读</li><li>便于单元测试</li><li>以react的useEffect hook为例 分离副作用可以精准控制副作用的触发时机 方便性能调度和优化</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>说了那么多，其实分离副作用的核心就是让代码更加优雅 同时减少开销</p><p>既然要分离，<strong>我们该如何优雅地处理副作用</strong>？</p><h1 id="副作用分离实战：React-与-Vue-框架指南"><a href="#副作用分离实战：React-与-Vue-框架指南" class="headerlink" title="副作用分离实战：React 与 Vue 框架指南"></a>副作用分离实战：React 与 Vue 框架指南</h1><h2 id="React框架下的实践"><a href="#React框架下的实践" class="headerlink" title="React框架下的实践"></a>React框架下的实践</h2><p>在 React 里，<strong>副作用的分离几乎是“官方强制”</strong>，尤其是函数组件+Hooks 流派。</p><h3 id="1-典型做法：用-useEffect-“圈养”副作用"><a href="#1-典型做法：用-useEffect-“圈养”副作用" class="headerlink" title="1. 典型做法：用 useEffect “圈养”副作用"></a>1. 典型做法：用 useEffect “圈养”副作用</h3><p>React 推荐所有副作用操作都写进 <code>useEffect</code>（或 <code>useLayoutEffect</code>）里，让组件的“主逻辑”（渲染&amp;交互）变成纯函数，副作用归副作用、逻辑归逻辑：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><br><span class="hljs-keyword">import</span> &#123; useEffect, useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">UserProfile</span>(<span class="hljs-params">&#123; userId &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [user, setUser] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 副作用：数据请求</span><br>    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/api/user/<span class="hljs-subst">$&#123;userId&#125;</span>`</span>)<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">json</span>())<br>      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> <span class="hljs-title function_">setUser</span>(data));<br>  &#125;, [userId]); <span class="hljs-comment">// 依赖数组，精准控制副作用触发</span><br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;user ? user.name : &#x27;Loading...&#x27;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>Tips:</p><ol><li><code>useEffect</code> 里的内容就是副作用。</li><li>依赖项 <code>[userId]</code>，保证副作用只在需要的时候执行。</li><li>组件的“渲染逻辑”天然保持纯粹。</li><li>注：实际项目中通常不建议直接在 <code>useEffect</code> 里裸写 <code>fetch</code>，推荐用封装好的请求库或 api 方法，便于统一错误处理和请求管理</li><li>注：useEffect 里的代码在渲染流程之后异步执行，不会阻塞渲染</li></ol></blockquote><h2 id="Vue框架下的实践"><a href="#Vue框架下的实践" class="headerlink" title="Vue框架下的实践"></a>Vue框架下的实践</h2><p>通过 <code>setup()</code>、<code>onMounted</code>、<code>onUnmounted</code> 和 <code>watch</code> 等 API，我们可以更细粒度地管理副作用，让逻辑解耦更加彻底：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; ref, watch, onMounted, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> username = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br><br><span class="hljs-comment">// 副作用1：生命周期内执行（如事件监听）</span><br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize);<br>&#125;);<br><span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, handleResize);<br>&#125;);<br><br><span class="hljs-comment">// 副作用2：监听数据变化（如自动校验）</span><br><span class="hljs-title function_">watch</span>(username, <span class="hljs-title function_">async</span> (newVal) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (newVal) &#123;<br>    <span class="hljs-comment">// 比如自动发请求校验用户名</span><br>    <span class="hljs-keyword">const</span> exists = <span class="hljs-keyword">await</span> <span class="hljs-title function_">checkUsername</span>(newVal);<br>    <span class="hljs-keyword">if</span> (exists) &#123;<br>      <span class="hljs-comment">// 弹窗、提示等都属于副作用</span><br>      <span class="hljs-title class_">ElMessage</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;用户名已存在&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResize</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 处理窗口变化</span><br>&#125;<br><br><span class="hljs-keyword">return</span> &#123; username &#125;;<br><br></code></pre></td></tr></table></figure><blockquote><p>Tips：</p><ul><li><code>onMounted</code>&#x2F;<code>onUnmounted</code> 负责“和外部世界打交道”（如订阅&#x2F;解绑）。</li><li><code>watch</code> 负责数据响应后的副作用操作（如自动请求、弹窗提示）。</li><li>主渲染逻辑和副作用逻辑泾渭分明，组件更易维护</li><li>很多同学一入门 Vue 就会用 watch 和生命周期钩子，但真正高级的分离副作用，是把副作用封装成 composable、精确控制依赖、善用副作用清理机制。只有这样，才能写出可维护、易扩展、无脏副作用的组件代码。</li></ul></blockquote><h1 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h1><p>副作用分离，是每一个现代前端开发者都绕不开的话题。刚入门时，我们可能只是在文档指导下“会用”生命周期和 watch，能把代码跑起来就算成功；但只有真正理解副作用的本质、学会分离与管理，才能让你的项目从“能跑”变得“优雅可维护”，甚至经得住时间和团队协作的考验。</p><p>无论你用 React 还是 Vue，记住这一点：<strong>主逻辑越“纯”，副作用越“规矩”，你的代码就越不容易变成屎山</strong>。</p><p>当你把副作用都圈进 useEffect、watch、composable 等“指定区域”，主逻辑清晰，副作用有序——这就是成熟开发者的工程素养。</p><p>就写到这里 希望你有所收获。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>实战</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端开发</tag>
      
      <tag>副作用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack初体验：基础配置</title>
    <link href="/2025/05/15/webpack_01/"/>
    <url>/2025/05/15/webpack_01/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>在笔者的印象里，从入门前端开始，用的构建工具好像一直是vite。</p><p>诚然，vite在中小型项目里，无论是<strong>启动速度</strong> 还是 <strong>模块热更新体验，</strong>都遥遥领先于webpack</p><p>但是，webpack在复杂项目的兼容性、插件生态方面有很大的优势。</p><p>相比于 Vite 主要依赖 Rollup 进行生产构建，Webpack 不仅提供了 <strong>更灵活的构建生命周期</strong>（如编译、优化、打包、输出等阶段），还拥有 <strong>强大的插件机制</strong>，使得其在 <strong>复杂项目和企业级应用中</strong> 更具优势。</p><p>同时,我过去的学习过程更多是基于 <strong>页面拼接与功能实现</strong>，而缺少对 <strong>模块化构建和项目架构设计</strong> 的深度理解。因此，通过学习 Webpack，我希望能够进一步掌握 <strong>模块依赖分析、资源优化、按需加载等前端核心架构能力</strong></p><p>因此，我开启了这个系列，旨在记录我的学习过程</p><p><del>fetch API 进阶用法仍在酝酿中，敬请期待</del> 😄</p><h1 id="2-Webpack是什么"><a href="#2-Webpack是什么" class="headerlink" title="2.Webpack是什么"></a>2.Webpack是什么</h1><p>Webpack 是一个<strong>模块打包器</strong>，它通过解析项目中的模块依赖关系，构建完整的依赖图（Dependency Graph），并最终将资源（JavaScript、CSS、图片等）统一打包为静态文件。</p><p>Webpack的核心以以下五个关键部分组成</p><h2 id="1-Entry（入口）"><a href="#1-Entry（入口）" class="headerlink" title="1. Entry（入口）"></a>1. <strong>Entry（入口）</strong></h2><ul><li><strong>作用：</strong> 指定打包的入口文件，Webpack 会从这个文件出发，构建整个依赖图。</li><li><strong>常见配置：</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>, <span class="hljs-comment">// 单入口</span><br>  <span class="hljs-comment">// entry: &#123; app: &#x27;./src/app.js&#x27;, admin: &#x27;./src/admin.js&#x27; &#125; // 多入口</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="2-Output（出口）"><a href="#2-Output（出口）" class="headerlink" title="2. Output（出口）"></a>2. <strong>Output（出口）</strong></h2><ul><li><strong>作用：</strong> 指定构建后文件的输出路径和文件名。</li><li><strong>常见配置：</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: __dirname + <span class="hljs-string">&#x27;/dist&#x27;</span>, <span class="hljs-comment">// 输出目录</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].bundle.js&#x27;</span>, <span class="hljs-comment">// 输出文件名</span><br>    <span class="hljs-attr">clean</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 构建前清理旧文件</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="3-Loaders（加载器）"><a href="#3-Loaders（加载器）" class="headerlink" title="3. Loaders（加载器）"></a>3. <strong>Loaders（加载器）</strong></h2><ul><li><strong>作用：</strong> 用于<strong>转换模块</strong>，让 Webpack 能识别除 JS 以外的文件，如 CSS、图片、字体等。</li><li><strong>常见 Loaders：</strong><ul><li><code>babel-loader</code>：将 ES6+ 转换为 ES5。</li><li><code>css-loader</code>：加载 CSS 文件。</li><li><code>style-loader</code>：将 CSS 插入到 DOM 中。</li><li><code>file-loader</code>：处理图片、字体等文件。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-attr">use</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>],<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="4-Plugins（插件）"><a href="#4-Plugins（插件）" class="headerlink" title="4. Plugins（插件）"></a>4. <strong>Plugins（插件）</strong></h2><ul><li><strong>作用：</strong> 扩展 Webpack 功能，比如优化打包、资源管理、注入环境变量等。</li><li><strong>常见 Plugins：</strong><ul><li><code>HtmlWebpackPlugin</code>：自动生成 HTML 文件并引入打包后的 JS。</li><li><code>MiniCssExtractPlugin</code>：分离 CSS 文件。</li><li><code>TerserPlugin</code>：压缩 JS 代码。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span>,<br>    &#125;),<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="5-Mode（模式）"><a href="#5-Mode（模式）" class="headerlink" title="5. Mode（模式）"></a>5. <strong>Mode（模式）</strong></h3><ul><li><strong>作用：</strong> 决定构建模式，内置三种模式：<ul><li><code>development</code>：开发模式，开启 Source Map，不压缩代码。</li><li><code>production</code>：生产模式，自动优化、压缩代码。</li><li><code>none</code>：不做任何优化，仅打包。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="3-从0开始-webpack应用的创建到基本配置"><a href="#3-从0开始-webpack应用的创建到基本配置" class="headerlink" title="3*. 从0开始  webpack应用的创建到基本配置"></a>3*. 从0开始  webpack应用的创建到基本配置</h1><h2 id="webpack应用的创建"><a href="#webpack应用的创建" class="headerlink" title="webpack应用的创建"></a>webpack应用的创建</h2><p><del>首先 我们创建项目文件夹</del></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> webpack-demo<br><span class="hljs-built_in">cd</span> webpack-demo<br></code></pre></td></tr></table></figure><p>在这个项目文件夹中 第一步 我们需先创建package.json</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm init<br></code></pre></td></tr></table></figure><p>pnpm 会快速生成基本package.json文件</p><p>随后 安装webpack(核心打包工具) 和 webpack-cli(命令行工具，用于执行 Webpack 命令)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack webpack-cli --save-dev<br></code></pre></td></tr></table></figure><blockquote><p>为什么要 <code>--save-dev</code>？</p></blockquote><blockquote><p>因为 Webpack 只在开发过程中使用，打包后的生产环境并不需要 Webpack 运行。</p></blockquote><p>然后 在项目的根目录下 创建src文件夹</p><p>在src文件里 创建index.js 作为整个项目的入口文件</p><p>随便写点简单的js吧</p><p>然后 我们需要创建webpack的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> webpack.config.js<br></code></pre></td></tr></table></figure><p>然后我们就需要对这个配置文件进行编辑</p><p>首先 因为webpack默认采用CommonJS模块规范</p><p>我们需要使用这样的结构导出</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>还记得之前说过的入口文件吗</p><p>我们通常以相对路径来配置它</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置完入口 我们自然而然会想到 这个项目构建完的产物需要放在哪里 即出口</p><p>但是由于指定的是文件输出路径 必须使用绝对路径进行配置</p><p>这时候我们就需要用到node.js提供的path模块来提供绝对路径</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>) <span class="hljs-comment">//导入node.js的path模块</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br><span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span><br><span class="hljs-attr">output</span>: &#123;<br><span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&#x27;dist&#x27;</span>) <span class="hljs-comment">//path.resolve用于拼接并解析出绝对路径</span><br><span class="hljs-comment">// __dirname是node的内置常量 指向当前文件夹</span><br><span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span> <span class="hljs-comment">//单入口项目通用写法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>注：多入口项目的写法这篇博客不会介绍 敬请期待</em></p><p>配置完这些 我们还需要让我们的包管理器能找到webpack </p><p>所以我们需要在package.json中加入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><p>一个最基础的webpack应用就构建完成了</p><h2 id="引入开发服务器-实现热重载"><a href="#引入开发服务器-实现热重载" class="headerlink" title="引入开发服务器 实现热重载"></a>引入开发服务器 实现热重载</h2><p>在开发过程中 我们肯定会对热重载有需求 但是前面部署的都是静态打包相关内容</p><p>于是我们今天更进一步 为我们的webpack应用安装webpack-dev-server</p><p>首先 安装相关依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install webpack-dev-server --save-dev<br></code></pre></td></tr></table></figure><p>然后 我们需要在webpack.config.js中加入devServer相关内容</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;./src/index.js&quot;</span>,<br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">resolve</span>(__dirname,<span class="hljs-string">&quot;dist&quot;</span>),<br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span><br>    &#125;,<br>    <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;development&quot;</span>,<br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">static</span>: path.<span class="hljs-title function_">join</span>(__dirname,<span class="hljs-string">&#x27;dist&#x27;</span>), <span class="hljs-comment">//静态文件目录</span><br>        <span class="hljs-comment">//path.join =&gt; 拼接多个路径</span><br>        <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span>, <span class="hljs-comment">//开发端口</span><br>        <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//自动打开浏览器</span><br>        <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">//支持热重载</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便启动 我们还需要在package.json里添加相关脚本</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span>,<br>    <span class="hljs-string">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack server&quot;</span> <span class="hljs-comment">//启动开发服务器</span><br>  &#125;,<br></code></pre></td></tr></table></figure><p>至此 我们的基本配置就完成了！</p><h1 id="4-写在最后"><a href="#4-写在最后" class="headerlink" title="4. 写在最后"></a>4. 写在最后</h1><p>这篇文章只是一个开始，旨在帮助大家完成 <strong>Webpack 的基础配置与应用初体验</strong>。</p><p>但 Webpack 远不止于此。</p><p>在后续文章中，我将逐步深入，分两个方向继续分享我的 Webpack 学习过程：</p><ul><li><strong>应用实战：</strong> 从基础配置到多入口配置、插件集成、生产环境优化，带你一步步构建完整的 Webpack 项目。</li><li><strong>原理剖析：</strong> 梳理 Webpack 的启动链路，从 <code>pnpm run build</code> 开始，到 <code>webpack.config.js</code> 的完整解析过程，深入剖析 <strong>CLI 模块、Compiler 模块、Compilation 模块</strong> 的内部工作原理。</li></ul><p>此外，关于 <strong>打包优化、模块分割、缓存策略</strong> 等高级优化方法，我也将陆续更新，敬请期待。</p><p>📦 <strong>项目源码：</strong> <a href="https://github.com/mao2006/webpack-demo">Webpack Demo - GitHub</a></p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
      <category>构建工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端开发</tag>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[闲谈] 从失速到重启：我的半年记录</title>
    <link href="/2025/05/14/reboot/"/>
    <url>/2025/05/14/reboot/</url>
    
    <content type="html"><![CDATA[<p>嘿，好久不见。</p><p>上次更新定格在了10.20  讲述的主题还是fetch api的基础用法 结果半年过去了 文章始终难产 上篇文章末的’未完待续‘现在看来有点像是一种讽刺</p><p>对我来说 这半年 说是沉淀 其实更像是一种失速 </p><p>从上学期的4u项目搁浅开始 我一度觉得自己的生活被按下了暂停键</p><p>但好在 最近论坛项目的重启 带着我重新按下了启动键</p><p>这一篇就当作和老朋友的闲聊，聊聊我这半年经历了些什么。 </p><h1 id="失速的几个月：为何按下暂停键"><a href="#失速的几个月：为何按下暂停键" class="headerlink" title="失速的几个月：为何按下暂停键"></a>失速的几个月：为何按下暂停键</h1><p>大概是半年前吧 4u项目还在如火如荼的进行 我像发了疯一样的push同事 同时也push着自己</p><p>刚刚通过了面试 加入精弘 完成试用期作业 猛刷任务版的我  期待的就是这么一个<strong>机会</strong></p><p>我很想通过这个<strong>机会</strong> 巩固我的技术 为培育我的精弘出一份力</p><p>更重要的是 我想证明我有<strong>独当一面</strong>的能力 所以我的目标是单挑完成管理端的前端开发</p><p>事情在某一天突然发生了变化</p><p>因为一些不可抗因素 4u项目在某几天突然宣布全面搁浅</p><p>我的最后一个commit 伴随那个无所不能的我 定格在了</p><p><img src="/images/reboot.png" alt="image.png"></p><p>那一周对我来说是无比痛苦的 但是也不能怪部长和前辈们 这件事情完全就是学校的失职</p><p>虽然后面仍然有不少项目在持续推进 但是我总感觉 自己的效率变得一塌糊涂</p><p>在前端的探索上也变得很被动 似乎是被强行带着走</p><p>这也就是 从2024.10.20 到最近 我博客停更的一个很大的原因</p><h1 id="失速期的进步：环境迁移与-React-初探"><a href="#失速期的进步：环境迁移与-React-初探" class="headerlink" title="失速期的进步：环境迁移与 React 初探"></a><strong>失速期的进步：环境迁移与 React 初探</strong></h1><p>虽然那段时间看似停滞不前，但我还是抓住了一些契机，尝试从技术层面重新调整自己。</p><h2 id="开发环境的迁移"><a href="#开发环境的迁移" class="headerlink" title="开发环境的迁移"></a>开发环境的迁移</h2><p>起初，我在 Windows 环境下开发还算顺利。</p><p>但是有一天，我有了真机调试的需求。</p><p>Windows 环境下的 Vite 服务器总让我头疼。页面加载不出来，控制台各种报错，甚至连刷新页面都能卡死。</p><p>折腾了一整天，从改配置到重启网络，折腾了无数次，结果还是不稳定。</p><p>调来调去，我终于意识到，这不是简单的配置问题，而是 <strong>网络环境和代理设置</strong> 的锅。</p><p>所以，我决定换个更稳定、更适合开发的系统：Ubuntu。</p><p>然而，这也导致了我这条懒狗 <strong>一直没把博客迁移到新环境</strong>，于是就这样一拖再拖，直到最近。</p><h2 id="技术栈的拓展"><a href="#技术栈的拓展" class="headerlink" title="技术栈的拓展"></a>技术栈的拓展</h2><p>就在我逐渐适应 Ubuntu 的时候，一个新的机会出现了。</p><p>我找到了一家小公司做线上实习，他们的技术栈是 React。之前我一直在用 Vue，对 React 的了解几乎停留在“它是个前端框架”这种程度。</p><p>刚开始接触 React，我觉得和 Vue 没什么区别。但当我真正深入了解它的时候，我才发现，React 的理念远比我想象的要复杂。</p><p>我发现 React 更像是一辆 <strong>手动挡汽车</strong>，许多 Vue 帮你封装好的优化逻辑，在 React 里都需要你手动处理，比如渲染优化等。</p><p>Hooks 模式则让我意识到，状态管理原来可以这么灵活。</p><p>对Fiber 架构的初步涉猎 让我对前端渲染的认知上了一个新的台阶，同时也对<strong>前端的深度</strong>多了一分敬畏。</p><p>所以，这段失速期对我来说，也是一个积累新技术、转变开发思路的过程。</p><h1 id="找回节奏：如何重新按下播放键"><a href="#找回节奏：如何重新按下播放键" class="headerlink" title="找回节奏：如何重新按下播放键"></a>找回节奏：如何重新按下播放键</h1><p>失速期讲了很多 但是当你们看到这篇文章的时候 也代表着 那个无所不能的我 似乎回来了</p><p>很幸运 众多契机叠加在了一起 让我走出了这段低谷</p><p>最重要的 当然是<strong>精弘论坛</strong>的启动 ****作为之前精弘的明星产品 这是一个学习的好机会 更是一个证明的好机会 强烈的渴望让我的齿轮再次启动 不断学习 不断工作 不断优化 不断进步</p><p>如果你也是精弘的一份子 是我的同事 是项目组的成员的话</p><blockquote><p><strong>做好准备</strong></p></blockquote><p>同时 我的感情似乎也有了一定的进展 这种奇妙的感觉让我不再是一只鹌鹑 不过现在还是发展阶段 我也不好多透露什么 (如果你是我的身边的人 别问我 问了我也不会告诉你)</p><p>这让我获得了前所未有的自信</p><p>然后就是 即将到来的改选 和 部长团选举</p><p>这是个沉重的话题 改选意味着 越来越多的前辈会离开我们 为生活奔忙</p><p>而部长团选举意味着 要展示自己的实力 赢得留在精弘的机会 也进一步代表了可用人手的减少</p><p>这样的压力如潮水一般  推动着我前进</p><p>这些恰到好处的契机 让我似乎重新回到了正轨 回到了去年秋天 回到了上学期的期中考试前后</p><h1 id="展望未来：工作与学习探索"><a href="#展望未来：工作与学习探索" class="headerlink" title="展望未来：工作与学习探索"></a>展望未来：工作与学习探索</h1><p>前面说到 最近的契机让我重回正轨 这也让我找到了新的方向</p><p>在工作方面，我希望以 <strong>半个 Owner 的身份</strong> 推进论坛项目开发，承担更多模块化设计和前端优化的工作，让论坛从功能实现到用户体验都有质的提升。</p><p>同时，我也计划积极准备部长团的面试，希望继续为精弘网络贡献自己的力量。</p><p>学习方面，接下来的两个月，我计划集中学习 Webpack 构建优化，深入理解其插件机制、模块打包原理，力求提升项目的构建效率。同时，我会同步学习 Next.js，通过研究它的 SSR 和 ISR 实现，来进一步理解前端框架的底层运作。</p><p>同时，我还准备系统化学习框架实现原理，包括路由、状态管理、虚拟 DOM 等模块，尝试从源码角度重新构建一个迷你框架。</p><p>希望这些能为未来的求职打下良好的基础。</p><p>接下来两个月，我还打算在博客上补上之前欠下的 Fetch API 进阶应用。虽然这篇未完待续已经拖了半年，但我依然会坚持写完。不过，由于当前项目和学习任务较重，预计更新会稍微延迟，还请耐心等待。</p><h1 id="写在最后：重新定义这片空白期"><a href="#写在最后：重新定义这片空白期" class="headerlink" title="写在最后：重新定义这片空白期"></a><strong>写在最后：重新定义这片空白期</strong></h1><p>这半年，看似空白，却也在我的心里留下了新的起点。失速并不可怕，关键是如何找到重启的契机。</p><p>对我来说，项目开发和技术写作，就是我重新按下播放键的动力源。</p><p>接下来的博客内容，我会继续写技术、写项目，也会多写写我这半年的思考。</p><p>毕竟，<strong>空白</strong>也是一种记录。</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>前端开发</tag>
      
      <tag>闲聊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解fetch api(1) --基础用法</title>
    <link href="/2024/10/20/fetch_api/"/>
    <url>/2024/10/20/fetch_api/</url>
    
    <content type="html"><![CDATA[<div style="color:#FFB7C5">相信不少最近刚学习前端的小伙伴，使用的都是axios请求库。诚然，axios是一个高度封装的http请求库，易于上手使用，但是随着学习的深入，其较大的包体积和不适合长时间处理的问题日益显现，因此，笔者将目光投向了主流的fetch api, 也就有了这篇文章的主题</div><h2 id="请求用法"><a href="#请求用法" class="headerlink" title="请求用法"></a><span style="color:#FF6F91">请求用法</span></h2><div style="color:#FFB7C5">这是最基础的fetch请求，注意，未声明请求方式的情况下，fetch发送的是get请求</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">比如我们需要发送一个post请求，就需要使用fetch api的第二个参数</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>,&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">如果后端使用了jwt鉴权，我们需要将token放入请求头中，我们就可以这么操作</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>,&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;your_token&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">实际操作中, 我们需要向后端传递相关参数</div><div style="color:#FFB7C5">与axios不同，axios可以直接添加params:{}传递参数，fetch api不原生支持params选项，所以我们需要通过<span style = "color:yellow">手动拼接url</span>的方式传递params参数</div><div style="color:#FFB7C5">例如我们现在有这样的一个对象字面量</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = &#123;<br>    <span class="hljs-attr">target</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">from</span>: <span class="hljs-number">2</span>,<br>&#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以使用javascript原生的<span style = "color:yellow">URLSearchParams构造函数</span>将其转化为查询字符串</div><div style="color:#FFB7C5">使用方法</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dataParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(data).<span class="hljs-title function_">toString</span>()<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">输出结果</div><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">target</span>=<span class="hljs-number">1</span>&amp;from=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">然后我们可以使用ES6新特性中的<span style = "color:yellow">模板字面量</span>拼接url</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.example.com/data?<span class="hljs-subst">$&#123;dataParams&#125;</span>`</span>,&#123; <span class="hljs-comment">//注意这里是反引号 `` 代表模板字面量 可以使用插值 $&#123;&#125;</span><br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;your_token&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">这样我们就成功传递了params参数</div><div style="color:#FFB7C5">fetch api在传递body参数时与axios大同小异，但是多了一<span style = "color:yellow">手动序列化</span>的流程, 这里我们借用一下上面提到的data对象来演示</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data) <span class="hljs-comment">// 手动序列化</span><br>&#125;);<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">这段代码中，我们就能很直观的看出与axios的区别，首先是请求头中'Content-Type'声明了请求体中传递的是JSON格式的数据，然后通过JS原生的JSON对象中的stringfy方法转化为json格式的字符串，这两个步骤就是上文提到的<span style = "color:yellow">手动序列化</span>，这样我们也就达成了传递body参数的目的</div><h2 id="处理返回"><a href="#处理返回" class="headerlink" title="处理返回"></a><span style="color:#FF6F91">处理返回</span></h2><div style="color:#FFB7C5">说完了发送请求，我们自然还要研究如何处理，不同于axios近乎傻瓜式的用法，fetch需要稍微复杂的处理</div><div style="color:#FFB7C5">fetch返回的是一个<span style = "color:yellow">promise对象</span>，最终会被解析为一个<span style = "color:yellow">response对象</span>，例如下面的代码</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>,&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;your_token&#x27;</span><br>    &#125;<br>&#125;)<br><br>fetchPromise.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">response的结构为</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">response &#123;<br>    <span class="hljs-attr">body</span>: <span class="hljs-title class_">ReadableStream</span>,<br>    <span class="hljs-attr">bodyUsed</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">headers</span>: <span class="hljs-title class_">Headers</span> &#123;<br>        <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json; charset=utf-8&quot;</span>,<br>        <span class="hljs-string">&quot;authorization&quot;</span>: <span class="hljs-string">&quot;your_token&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">redirected</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">statusText</span>: <span class="hljs-string">&quot;OK&quot;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;basic&quot;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://api.example.com/data&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以显式的获取一些状态，比如说状态码和ok(是否访问成功), 以及访问头</div><div style="color:#FFB7C5">但是注意，<span style = "color:yellow">body是一个流，不能一次性获取所有内容</span>，这里涉及到另一个异步操作，下面给出具体的代码</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 解析 JSON 数据 注意 这是一个异步操作 所以需要一个.then来读取</span><br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 指向response.json()</span><br>&#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">这样我们就可以读取后端返回的内容了,但是还得注意的是，<span style = "color:yellow">除非网络请求本身出现问题（无法连接到服务器等），fetch不会主动的抛出一个错误，即使是请求失败（404和500），也会返回一个成功的promise</span>，这里就需要我们自己来从处理error, 下面给出简单的代码示例</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchPromise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;网络响应错误，状态码：&#x27;</span> + response.<span class="hljs-property">status</span>); <span class="hljs-comment">//访问失败，抛出错误</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败:&#x27;</span>, error); <span class="hljs-comment">// 打印错误信息</span><br>  &#125;);<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">上述代码中，throw能让控制流转到最近的catch模块, 而new Error构造函数能创建一个错误对象，通过这种方式，我们可以成功的处理未捕捉到的请求错误问题</div><p><br><br></p><h3 id="综上即是fetch-api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案"><a href="#综上即是fetch-api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案" class="headerlink" title="综上即是fetch api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案"></a><div style="color:#FF6F91">综上即是fetch api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案</div></h3><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a><div style="color:#FF6F91">未完待续…</div></h3>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>样式隔离简介</title>
    <link href="/2024/10/18/style_isolation/"/>
    <url>/2024/10/18/style_isolation/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><span style="color:#FF6F91">简介</span></h2><div style="color:#FFB7C5">众所周知，css在web前端中具有样式控制、布局设计等重要作用。但是我们经常会遇到一个问题，就是修改一个组件的样式时会不自觉的影响到别的组件,比如说覆盖了上个已写好的背景颜色。这个问题叫做样式冲突。正因为这个问题，也就引出的这篇博客的主题-<span style='color:yellow;font-size:20px'>样式隔离</span>。下面笔者就对比简介css module、tailwindcss、vue css scoped的样式隔离方案</div><h2 id="CSS-MODULE的样式隔离方案"><a href="#CSS-MODULE的样式隔离方案" class="headerlink" title="CSS MODULE的样式隔离方案"></a><span style="color:#FF6F91">CSS MODULE的样式隔离方案</span></h2><div style="color:#FFB7C5">与一般的.css文件不同，.module.css在导入时会将类名封装在一个对象字面量里面，原先的类名作为对象的键，而值是经过修饰过的类名，以此达到样式隔离的目的</div><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">我们不妨来看这么一段代码</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs .module.css">.container &#123;<br>    background-color: blue;<br>    color: white;<br>    padding: 20px;<br>&#125;<br><br>.title &#123;<br>    font-size: 24px;<br>    font-weight: bold;<br>&#125;<br><br>.button &#123;<br>    background-color: green;<br>    color: white;<br>    padding: 10px;<br>    border: none;<br>    border-radius: 5px;<br>    cursor: pointer;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> ./style.<span class="hljs-property">module</span>.<span class="hljs-property">css</span><br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">导入后, javascript会生成类似这样的对象</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> styles = &#123;<br>  <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;container__1a2b3&#x27;</span>, <br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;title__1a2b3&#x27;</span>, <br>  <span class="hljs-attr">button</span>: <span class="hljs-string">&#x27;button__1a2b3&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">而对象的值作为新的类名，这样的方式让多处导入的同名类不会相互影响，以此达到了样式隔离的目的</div><h2 id="tailwindcss的样式隔离方案"><a href="#tailwindcss的样式隔离方案" class="headerlink" title="tailwindcss的样式隔离方案"></a><span style="color:#FF6F91">tailwindcss的样式隔离方案</span></h2><div style="color:#FFB7C5">与一般的css不同，tailwind使用了<span style="color:yellow">原子化CSS（Atomic CSS）</span>的设计理念来规避样式冲突问题，即一个类只包含一条CSS，或者说只干一件事情</div><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">我们不妨以这么一段简单的代码为例</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lg:text-xl&quot;</span>&gt;</span><br>  Hello, World!<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">这段代码的意思是在屏幕较大的时候显示较大的字体,而打开tailwind生成的文件我们会发现, 这段代码被转化成了</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.lg</span>\\:text-xl &#123;\n    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.25rem</span>;\n    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.75rem</span>;\n  &#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">输出了一个css文件，并且在app.vue中导入 <br><br> 当类名变多时 如</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lg:text-xl p-5&quot;</span>&gt;</span><br>  Hello, World!<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以看到生成了这样一个文件</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.p-5</span> &#123;\n  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;\n&#125;<br><span class="hljs-selector-class">.lg</span>\\:text-xl &#123;\n    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.25rem</span>;\n    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.75rem</span>;\n  &#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">那么我们不难得出tailwind的工作原理:</div><ol style="color:yellow"><li>获取用户设置的class类，判断是否符合组件库规范<li>用空格拆分用户的class，将其转化为单独的类，每个类对应一条css<li>将每个类生成的css组合 输出一个有独特名字的css文件 包含一个名称与原class相同的css文件<li>将css文件导入组件，正常使用</ol><div style="color:#FFB7C5">正因如此，就算两个组件使用了相同的class类名，因为一个类名指向一个固定的css样式，有效的规避了样式冲突问题</div><h2 id="vue-css-scopped样式隔离方案"><a href="#vue-css-scopped样式隔离方案" class="headerlink" title="vue css scopped样式隔离方案"></a><span style="color:#FF6F91">vue css scopped样式隔离方案</span></h2><div style="color:#FFB7C5">在vue的style标签中添加scopped属性后，可以让组件的样式仅适用与该组件而不影响其他组件，以此来达到样式隔离的效果</div>  <h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">与css module类似，使用scopped属性后，vue会为每个css选择器添加一个独特的属性，确保不会被其他组件影响</div>  <div style="color:#FFB7C5">例如</div>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style scoped&gt;<br>.my-component &#123;<br>    background-color: lightblue;<br>    color: white;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">.my-component 会被转换为 .my-component[data-v-xxxxxx], 也就不会被全局样式所影响</div><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><span style="color:#FF6F91">作用</span></h2><div style="color:#FFB7C5">除了解决简述中的样式冲突问题, 样式隔离还有不少好处</div><h3 id="提高可维护性"><a href="#提高可维护性" class="headerlink" title="提高可维护性"></a><span style="color:#FF6F91">提高可维护性</span></h3><div style="color:#FFB7C5">传统的全局css样式往往是牵一发而动一身的，这给代码维护造成了很大的麻烦，而隔离了样式之后就能避免这一问题</div><h3 id="增强复用性"><a href="#增强复用性" class="headerlink" title="增强复用性"></a><span style="color:#FF6F91">增强复用性</span></h3><div style="color:#FFB7C5">复用是前端领域非常重要的一块，而样式隔离可以让复用组件的成本更低</div><h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a><span style="color:#FF6F91">团队协作</span></h3><div style="color:#FFB7C5">团队的不同成员可能会同时修改样式，样式隔离可以很好解决这个问题</div>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开博纪念</title>
    <link href="/2024/10/02/my_first_blog/"/>
    <url>/2024/10/02/my_first_blog/</url>
    
    <content type="html"><![CDATA[<p>我的第一篇博客</p><h2 id="关于窝"><a href="#关于窝" class="headerlink" title="关于窝"></a>关于窝</h2><h3 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h3><p>学生 就读于 zjut - 浙江工业大学</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>HTML&#x2F;CSS JavaScript Vue.js lua</p><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><p>足球 DOTA2 魔兽世界 炉石传说 CS2</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
