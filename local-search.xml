<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[闲谈] 从失速到重启：我的半年记录</title>
    <link href="/2025/05/14/reboot/"/>
    <url>/2025/05/14/reboot/</url>
    
    <content type="html"><![CDATA[<p>嘿，好久不见。</p><p>上次更新定格在了10.20  讲述的主题还是fetch api的基础用法 结果半年过去了 文章始终难产 上篇文章末的’未完待续‘现在看来有点像是一种讽刺</p><p>对我来说 这半年 说是沉淀 其实更像是一种失速 </p><p>从上学期的4u项目搁浅开始 我一度觉得自己的生活被按下了暂停键</p><p>但好在 最近论坛项目的重启 带着我重新按下了启动键</p><p>这一篇就当作和老朋友的闲聊，聊聊我这半年经历了些什么。 </p><h1 id="失速的几个月：为何按下暂停键"><a href="#失速的几个月：为何按下暂停键" class="headerlink" title="失速的几个月：为何按下暂停键"></a>失速的几个月：为何按下暂停键</h1><p>大概是半年前吧 4u项目还在如火如荼的进行 我像发了疯一样的push同事 同时也push着自己</p><p>刚刚通过了面试 加入精弘 完成试用期作业 猛刷任务版的我  期待的就是这么一个<strong>机会</strong></p><p>我很想通过这个<strong>机会</strong> 巩固我的技术 为培育我的精弘出一份力</p><p>更重要的是 我想证明我有<strong>独当一面</strong>的能力 所以我的目标是单挑完成管理端的前端开发</p><p>事情在某一天突然发生了变化</p><p>因为一些不可抗因素 4u项目在某几天突然宣布全面搁浅</p><p>我的最后一个commit 伴随那个无所不能的我 定格在了</p><p><img src="/images/reboot.png" alt="image.png"></p><p>那一周对我来说是无比痛苦的 但是也不能怪部长和前辈们 这件事情完全就是学校的失职</p><p>虽然后面仍然有不少项目在持续推进 但是我总感觉 自己的效率变得一塌糊涂</p><p>在前端的探索上也变得很被动 似乎是被强行带着走</p><p>这也就是 从2024.10.20 到最近 我博客停更的一个很大的原因</p><h1 id="失速期的进步：环境迁移与-React-初探"><a href="#失速期的进步：环境迁移与-React-初探" class="headerlink" title="失速期的进步：环境迁移与 React 初探"></a><strong>失速期的进步：环境迁移与 React 初探</strong></h1><p>虽然那段时间看似停滞不前，但我还是抓住了一些契机，尝试从技术层面重新调整自己。</p><h2 id="开发环境的迁移"><a href="#开发环境的迁移" class="headerlink" title="开发环境的迁移"></a>开发环境的迁移</h2><p>起初，我在 Windows 环境下开发还算顺利。</p><p>但是有一天，我有了真机调试的需求。</p><p>Windows 环境下的 Vite 服务器总让我头疼。页面加载不出来，控制台各种报错，甚至连刷新页面都能卡死。</p><p>折腾了一整天，从改配置到重启网络，折腾了无数次，结果还是不稳定。</p><p>调来调去，我终于意识到，这不是简单的配置问题，而是 <strong>网络环境和代理设置</strong> 的锅。</p><p>所以，我决定换个更稳定、更适合开发的系统：Ubuntu。</p><p>然而，这也导致了我这条懒狗 <strong>一直没把博客迁移到新环境</strong>，于是就这样一拖再拖，直到最近。</p><h2 id="技术栈的拓展"><a href="#技术栈的拓展" class="headerlink" title="技术栈的拓展"></a>技术栈的拓展</h2><p>就在我逐渐适应 Ubuntu 的时候，一个新的机会出现了。</p><p>我找到了一家小公司做线上实习，他们的技术栈是 React。之前我一直在用 Vue，对 React 的了解几乎停留在“它是个前端框架”这种程度。</p><p>刚开始接触 React，我觉得和 Vue 没什么区别。但当我真正深入了解它的时候，我才发现，React 的理念远比我想象的要复杂。</p><p>我发现 React 更像是一辆 <strong>手动挡汽车</strong>，许多 Vue 帮你封装好的优化逻辑，在 React 里都需要你手动处理，比如渲染优化等。</p><p>Hooks 模式则让我意识到，状态管理原来可以这么灵活。</p><p>对Fiber 架构的初步涉猎 让我对前端渲染的认知上了一个新的台阶，同时也对<strong>前端的深度</strong>多了一分敬畏。</p><p>所以，这段失速期对我来说，也是一个积累新技术、转变开发思路的过程。</p><h1 id="找回节奏：如何重新按下播放键"><a href="#找回节奏：如何重新按下播放键" class="headerlink" title="找回节奏：如何重新按下播放键"></a>找回节奏：如何重新按下播放键</h1><p>失速期讲了很多 但是当你们看到这篇文章的时候 也代表着 那个无所不能的我 似乎回来了</p><p>很幸运 众多契机叠加在了一起 让我走出了这段低谷</p><p>最重要的 当然是<strong>精弘论坛</strong>的启动 ****作为之前精弘的明星产品 这是一个学习的好机会 更是一个证明的好机会 强烈的渴望让我的齿轮再次启动 不断学习 不断工作 不断优化 不断进步</p><p>如果你也是精弘的一份子 是我的同事 是项目组的成员的话</p><blockquote><p><strong>做好准备</strong></p></blockquote><p>同时 我的感情似乎也有了一定的进展 这种奇妙的感觉让我不再是一只鹌鹑 不过现在还是发展阶段 我也不好多透露什么 (如果你是我的身边的人 别问我 问了我也不会告诉你)</p><p>这让我获得了前所未有的自信</p><p>然后就是 即将到来的改选 和 部长团选举</p><p>这是个沉重的话题 改选意味着 越来越多的前辈会离开我们 为生活奔忙</p><p>而部长团选举意味着 要展示自己的实力 赢得留在精弘的机会 也进一步代表了可用人手的减少</p><p>这样的压力如潮水一般  推动着我前进</p><p>这些恰到好处的契机 让我似乎重新回到了正轨 回到了去年秋天 回到了上学期的期中考试前后</p><h1 id="展望未来：工作与学习探索"><a href="#展望未来：工作与学习探索" class="headerlink" title="展望未来：工作与学习探索"></a>展望未来：工作与学习探索</h1><p>前面说到 最近的契机让我重回正轨 这也让我找到了新的方向</p><p>在工作方面，我希望以 <strong>半个 Owner 的身份</strong> 推进论坛项目开发，承担更多模块化设计和前端优化的工作，让论坛从功能实现到用户体验都有质的提升。</p><p>同时，我也计划积极准备部长团的面试，继续为精弘网络贡献自己的力量。</p><p>学习方面，接下来的两个月，我计划集中学习 Webpack 构建优化，深入理解其插件机制、模块打包原理，力求提升项目的构建效率。同时，我会同步学习 Next.js，通过研究它的 SSR 和 ISR 实现，来进一步理解前端框架的底层运作。</p><p>同时，我还准备系统化学习框架实现原理，包括路由、状态管理、虚拟 DOM 等模块，尝试从源码角度重新构建一个迷你框架。</p><p>希望这些能为未来的求职打下良好的基础。</p><p>接下来两个月，我还打算在博客上补上之前欠下的 Fetch API 进阶应用。虽然这篇未完待续已经拖了半年，但我依然会坚持写完。不过，由于当前项目和学习任务较重，预计更新会稍微延迟，还请耐心等待。</p><h1 id="写在最后：重新定义这片空白期"><a href="#写在最后：重新定义这片空白期" class="headerlink" title="写在最后：重新定义这片空白期"></a><strong>写在最后：重新定义这片空白期</strong></h1><p>这半年，看似空白，却也在我的心里留下了新的起点。失速并不可怕，关键是如何找到重启的契机。</p><p>对我来说，项目开发和技术写作，就是我重新按下播放键的动力源。</p><p>接下来的博客内容，我会继续写技术、写项目，也会多写写我这半年的思考。</p><p>毕竟，<strong>空白</strong>也是一种记录。</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>前端开发</tag>
      
      <tag>闲聊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解fetch api(1) --基础用法</title>
    <link href="/2024/10/20/fetch_api/"/>
    <url>/2024/10/20/fetch_api/</url>
    
    <content type="html"><![CDATA[<div style="color:#FFB7C5">相信不少最近刚学习前端的小伙伴，使用的都是axios请求库。诚然，axios是一个高度封装的http请求库，易于上手使用，但是随着学习的深入，其较大的包体积和不适合长时间处理的问题日益显现，因此，笔者将目光投向了主流的fetch api, 也就有了这篇文章的主题</div><h2 id="请求用法"><a href="#请求用法" class="headerlink" title="请求用法"></a><span style="color:#FF6F91">请求用法</span></h2><div style="color:#FFB7C5">这是最基础的fetch请求，注意，未声明请求方式的情况下，fetch发送的是get请求</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">比如我们需要发送一个post请求，就需要使用fetch api的第二个参数</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>,&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">如果后端使用了jwt鉴权，我们需要将token放入请求头中，我们就可以这么操作</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>,&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;your_token&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">实际操作中, 我们需要向后端传递相关参数</div><div style="color:#FFB7C5">与axios不同，axios可以直接添加params:{}传递参数，fetch api不原生支持params选项，所以我们需要通过<span style = "color:yellow">手动拼接url</span>的方式传递params参数</div><div style="color:#FFB7C5">例如我们现在有这样的一个对象字面量</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> data = &#123;<br>    <span class="hljs-attr">target</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">from</span>: <span class="hljs-number">2</span>,<br>&#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以使用javascript原生的<span style = "color:yellow">URLSearchParams构造函数</span>将其转化为查询字符串</div><div style="color:#FFB7C5">使用方法</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dataParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(data).<span class="hljs-title function_">toString</span>()<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">输出结果</div><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">target</span>=<span class="hljs-number">1</span>&amp;from=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">然后我们可以使用ES6新特性中的<span style = "color:yellow">模板字面量</span>拼接url</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">`https://api.example.com/data?<span class="hljs-subst">$&#123;dataParams&#125;</span>`</span>,&#123; <span class="hljs-comment">//注意这里是反引号 `` 代表模板字面量 可以使用插值 $&#123;&#125;</span><br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;your_token&#x27;</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">这样我们就成功传递了params参数</div><div style="color:#FFB7C5">fetch api在传递body参数时与axios大同小异，但是多了一<span style = "color:yellow">手动序列化</span>的流程, 这里我们借用一下上面提到的data对象来演示</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data) <span class="hljs-comment">// 手动序列化</span><br>&#125;);<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">这段代码中，我们就能很直观的看出与axios的区别，首先是请求头中'Content-Type'声明了请求体中传递的是JSON格式的数据，然后通过JS原生的JSON对象中的stringfy方法转化为json格式的字符串，这两个步骤就是上文提到的<span style = "color:yellow">手动序列化</span>，这样我们也就达成了传递body参数的目的</div><h2 id="处理返回"><a href="#处理返回" class="headerlink" title="处理返回"></a><span style="color:#FF6F91">处理返回</span></h2><div style="color:#FFB7C5">说完了发送请求，我们自然还要研究如何处理，不同于axios近乎傻瓜式的用法，fetch需要稍微复杂的处理</div><div style="color:#FFB7C5">fetch返回的是一个<span style = "color:yellow">promise对象</span>，最终会被解析为一个<span style = "color:yellow">response对象</span>，例如下面的代码</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fetchPromise = <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>,&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;post&#x27;</span>,<br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">&#x27;your_token&#x27;</span><br>    &#125;<br>&#125;)<br><br>fetchPromise.<span class="hljs-title function_">then</span>(<br>    <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">response的结构为</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">response &#123;<br>    <span class="hljs-attr">body</span>: <span class="hljs-title class_">ReadableStream</span>,<br>    <span class="hljs-attr">bodyUsed</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">headers</span>: <span class="hljs-title class_">Headers</span> &#123;<br>        <span class="hljs-string">&quot;content-type&quot;</span>: <span class="hljs-string">&quot;application/json; charset=utf-8&quot;</span>,<br>        <span class="hljs-string">&quot;authorization&quot;</span>: <span class="hljs-string">&quot;your_token&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">redirected</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">statusText</span>: <span class="hljs-string">&quot;OK&quot;</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&quot;basic&quot;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&quot;https://api.example.com/data&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以显式的获取一些状态，比如说状态码和ok(是否访问成功), 以及访问头</div><div style="color:#FFB7C5">但是注意，<span style = "color:yellow">body是一个流，不能一次性获取所有内容</span>，这里涉及到另一个异步操作，下面给出具体的代码</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchPromise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>(); <span class="hljs-comment">// 解析 JSON 数据 注意 这是一个异步操作 所以需要一个.then来读取</span><br>&#125;)<br>.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data); <span class="hljs-comment">// 指向response.json()</span><br>&#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">这样我们就可以读取后端返回的内容了,但是还得注意的是，<span style = "color:yellow">除非网络请求本身出现问题（无法连接到服务器等），fetch不会主动的抛出一个错误，即使是请求失败（404和500），也会返回一个成功的promise</span>，这里就需要我们自己来从处理error, 下面给出简单的代码示例</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetchPromise<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!response.<span class="hljs-property">ok</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;网络响应错误，状态码：&#x27;</span> + response.<span class="hljs-property">status</span>); <span class="hljs-comment">//访问失败，抛出错误</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败:&#x27;</span>, error); <span class="hljs-comment">// 打印错误信息</span><br>  &#125;);<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">上述代码中，throw能让控制流转到最近的catch模块, 而new Error构造函数能创建一个错误对象，通过这种方式，我们可以成功的处理未捕捉到的请求错误问题</div><p><br><br></p><h3 id="综上即是fetch-api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案"><a href="#综上即是fetch-api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案" class="headerlink" title="综上即是fetch api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案"></a><div style="color:#FF6F91">综上即是fetch api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案</div></h3><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a><div style="color:#FF6F91">未完待续…</div></h3><h3 id="了解了基础的fetch用法-下面我们来给出进阶的封装方法"><a href="#了解了基础的fetch用法-下面我们来给出进阶的封装方法" class="headerlink" title="了解了基础的fetch用法 下面我们来给出进阶的封装方法"></a><div style="color:#FF6F91">了解了基础的fetch用法 下面我们来给出进阶的封装方法</div></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FetchOptions</span> &#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">params</span>?: <span class="hljs-built_in">any</span>,<br>    <span class="hljs-attr">body</span>?: <span class="hljs-built_in">any</span>,<br>    <span class="hljs-title class_">Authorization</span>?: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchInstance</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"><span class="hljs-attr">options</span>: <span class="hljs-title class_">FetchOptions</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> &#123; url, method, params, body, <span class="hljs-title class_">Authorization</span> &#125; = options;<br>    <span class="hljs-keyword">const</span> response = &#123;<br>        <span class="hljs-attr">status</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-literal">null</span>,<br>        <span class="hljs-attr">errorMessage</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> completeURL = params ? url + <span class="hljs-string">&quot;?&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(params).<span class="hljs-title function_">toString</span>() : url;<br>        <span class="hljs-keyword">const</span> resultPromise = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(completeURL, &#123;<br>            <span class="hljs-attr">method</span>: method,<br>            <span class="hljs-attr">headers</span>: &#123;<br>                ...(<span class="hljs-title class_">Authorization</span> ? &#123; <span class="hljs-title class_">Authorization</span>: <span class="hljs-title class_">Authorization</span> &#125; : &#123;&#125;),<br>                <span class="hljs-string">&quot;Content-Type&quot;</span>: <span class="hljs-string">&quot;application/json&quot;</span><br>            &#125;,<br>            ...(body ? &#123; <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(body) &#125; : &#123;&#125;)<br>        &#125;);<br><br>        <span class="hljs-keyword">if</span> (!resultPromise.<span class="hljs-property">ok</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;网络连接错误,状态码为&quot;</span> + resultPromise.<span class="hljs-property">status</span>);<br>        &#125;<br><br>        response.<span class="hljs-property">status</span> = <span class="hljs-literal">true</span>;<br>        response.<span class="hljs-property">data</span> = <span class="hljs-keyword">await</span> resultPromise.<span class="hljs-title function_">json</span>();<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-keyword">if</span> (error <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Error</span>) &#123;<br>            response.<span class="hljs-property">errorMessage</span> = error.<span class="hljs-property">message</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>        response<br>    &#125;;<br>&#125;;<br><br><span class="hljs-keyword">export</span> &#123; fetchInstance &#125;;<br></code></pre></td></tr></table></figure><h2 id="这是笔者封装的建议fetch接口-下面给出详细的解释"><a href="#这是笔者封装的建议fetch接口-下面给出详细的解释" class="headerlink" title="这是笔者封装的建议fetch接口 下面给出详细的解释"></a>这是笔者封装的建议fetch接口 下面给出详细的解释</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FetchOptions</span> &#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">params</span>?: <span class="hljs-built_in">any</span>,<br>    <span class="hljs-attr">body</span>?: <span class="hljs-built_in">any</span>,<br>    <span class="hljs-title class_">Authorization</span>?: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="这一段定义了传入参数的类型防止传入错误影响网络请求"><a href="#这一段定义了传入参数的类型防止传入错误影响网络请求" class="headerlink" title="这一段定义了传入参数的类型防止传入错误影响网络请求"></a>这一段定义了传入参数的类型防止传入错误影响网络请求</h3>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>样式隔离简介</title>
    <link href="/2024/10/18/style_isolation/"/>
    <url>/2024/10/18/style_isolation/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><span style="color:#FF6F91">简介</span></h2><div style="color:#FFB7C5">众所周知，css在web前端中具有样式控制、布局设计等重要作用。但是我们经常会遇到一个问题，就是修改一个组件的样式时会不自觉的影响到别的组件,比如说覆盖了上个已写好的背景颜色。这个问题叫做样式冲突。正因为这个问题，也就引出的这篇博客的主题-<span style='color:yellow;font-size:20px'>样式隔离</span>。下面笔者就对比简介css module、tailwindcss、vue css scoped的样式隔离方案</div><h2 id="CSS-MODULE的样式隔离方案"><a href="#CSS-MODULE的样式隔离方案" class="headerlink" title="CSS MODULE的样式隔离方案"></a><span style="color:#FF6F91">CSS MODULE的样式隔离方案</span></h2><div style="color:#FFB7C5">与一般的.css文件不同，.module.css在导入时会将类名封装在一个对象字面量里面，原先的类名作为对象的键，而值是经过修饰过的类名，以此达到样式隔离的目的</div><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">我们不妨来看这么一段代码</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs .module.css">.container &#123;<br>    background-color: blue;<br>    color: white;<br>    padding: 20px;<br>&#125;<br><br>.title &#123;<br>    font-size: 24px;<br>    font-weight: bold;<br>&#125;<br><br>.button &#123;<br>    background-color: green;<br>    color: white;<br>    padding: 10px;<br>    border: none;<br>    border-radius: 5px;<br>    cursor: pointer;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> ./style.<span class="hljs-property">module</span>.<span class="hljs-property">css</span><br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">导入后, javascript会生成类似这样的对象</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> styles = &#123;<br>  <span class="hljs-attr">container</span>: <span class="hljs-string">&#x27;container__1a2b3&#x27;</span>, <br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;title__1a2b3&#x27;</span>, <br>  <span class="hljs-attr">button</span>: <span class="hljs-string">&#x27;button__1a2b3&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">而对象的值作为新的类名，这样的方式让多处导入的同名类不会相互影响，以此达到了样式隔离的目的</div><h2 id="tailwindcss的样式隔离方案"><a href="#tailwindcss的样式隔离方案" class="headerlink" title="tailwindcss的样式隔离方案"></a><span style="color:#FF6F91">tailwindcss的样式隔离方案</span></h2><div style="color:#FFB7C5">与一般的css不同，tailwind使用了<span style="color:yellow">原子化CSS（Atomic CSS）</span>的设计理念来规避样式冲突问题，即一个类只包含一条CSS，或者说只干一件事情</div><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">我们不妨以这么一段简单的代码为例</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lg:text-xl&quot;</span>&gt;</span><br>  Hello, World!<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">这段代码的意思是在屏幕较大的时候显示较大的字体,而打开tailwind生成的文件我们会发现, 这段代码被转化成了</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.lg</span>\\:text-xl &#123;\n    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.25rem</span>;\n    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.75rem</span>;\n  &#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">输出了一个css文件，并且在app.vue中导入 <br><br> 当类名变多时 如</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;lg:text-xl p-5&quot;</span>&gt;</span><br>  Hello, World!<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以看到生成了这样一个文件</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.p-5</span> &#123;\n  <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>;\n&#125;<br><span class="hljs-selector-class">.lg</span>\\:text-xl &#123;\n    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.25rem</span>;\n    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.75rem</span>;\n  &#125;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">那么我们不难得出tailwind的工作原理:</div><ol style="color:yellow"><li>获取用户设置的class类，判断是否符合组件库规范<li>用空格拆分用户的class，将其转化为单独的类，每个类对应一条css<li>将每个类生成的css组合 输出一个有独特名字的css文件 包含一个名称与原class相同的css文件<li>将css文件导入组件，正常使用</ol><div style="color:#FFB7C5">正因如此，就算两个组件使用了相同的class类名，因为一个类名指向一个固定的css样式，有效的规避了样式冲突问题</div><h2 id="vue-css-scopped样式隔离方案"><a href="#vue-css-scopped样式隔离方案" class="headerlink" title="vue css scopped样式隔离方案"></a><span style="color:#FF6F91">vue css scopped样式隔离方案</span></h2><div style="color:#FFB7C5">在vue的style标签中添加scopped属性后，可以让组件的样式仅适用与该组件而不影响其他组件，以此来达到样式隔离的效果</div>  <h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">与css module类似，使用scopped属性后，vue会为每个css选择器添加一个独特的属性，确保不会被其他组件影响</div>  <div style="color:#FFB7C5">例如</div>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style scoped&gt;<br>.my-component &#123;<br>    background-color: lightblue;<br>    color: white;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><div style="color:#FFB7C5">.my-component 会被转换为 .my-component[data-v-xxxxxx], 也就不会被全局样式所影响</div><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><span style="color:#FF6F91">作用</span></h2><div style="color:#FFB7C5">除了解决简述中的样式冲突问题, 样式隔离还有不少好处</div><h3 id="提高可维护性"><a href="#提高可维护性" class="headerlink" title="提高可维护性"></a><span style="color:#FF6F91">提高可维护性</span></h3><div style="color:#FFB7C5">传统的全局css样式往往是牵一发而动一身的，这给代码维护造成了很大的麻烦，而隔离了样式之后就能避免这一问题</div><h3 id="增强复用性"><a href="#增强复用性" class="headerlink" title="增强复用性"></a><span style="color:#FF6F91">增强复用性</span></h3><div style="color:#FFB7C5">复用是前端领域非常重要的一块，而样式隔离可以让复用组件的成本更低</div><h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a><span style="color:#FF6F91">团队协作</span></h3><div style="color:#FFB7C5">团队的不同成员可能会同时修改样式，样式隔离可以很好解决这个问题</div>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开博纪念</title>
    <link href="/2024/10/02/my_first_blog/"/>
    <url>/2024/10/02/my_first_blog/</url>
    
    <content type="html"><![CDATA[<p>我的第一篇博客</p><h2 id="关于窝"><a href="#关于窝" class="headerlink" title="关于窝"></a>关于窝</h2><h3 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h3><p>学生 就读于 zjut - 浙江工业大学</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>HTML&#x2F;CSS JavaScript Vue.js lua</p><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><p>足球 DOTA2 魔兽世界 炉石传说 CS2</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
