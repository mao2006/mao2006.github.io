<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>深入理解fetch api(1) --基础用法</title>
    <link href="/2024/10/20/fetch_api/"/>
    <url>/2024/10/20/fetch_api/</url>
    
    <content type="html"><![CDATA[<div style="color:#FFB7C5">相信不少最近刚学习前端的小伙伴，使用的都是axios请求库。诚然，axios是一个高度封装的http请求库，易于上手使用，但是随着学习的深入，其较大的包体积和不适合长时间处理的问题日益显现，因此，笔者将目光投向了主流的fetch api, 也就有了这篇文章的主题</div><h2 id="请求用法"><a href="#请求用法" class="headerlink" title="请求用法"></a><span style="color:#FF6F91">请求用法</span></h2><div style="color:#FFB7C5">这是最基础的fetch请求，注意，未声明请求方式的情况下，fetch发送的是get请求</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>)</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">比如我们需要发送一个post请求，就需要使用fetch api的第二个参数</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">如果后端使用了jwt鉴权，我们需要将token放入请求头中，我们就可以这么操作</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="title class_">Authorization</span>: <span class="string">&#x27;your_token&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">实际操作中, 我们需要向后端传递相关参数</div><div style="color:#FFB7C5">与axios不同，axios可以直接添加params:{}传递参数，fetch api不原生支持params选项，所以我们需要通过<span style = "color:yellow">手动拼接url</span>的方式传递params参数</div><div style="color:#FFB7C5">例如我们现在有这样的一个对象字面量</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">target</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">from</span>: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以使用javascript原生的<span style = "color:yellow">URLSearchParams构造函数</span>将其转化为查询字符串</div><div style="color:#FFB7C5">使用方法</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(data).<span class="title function_">toString</span>()</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">输出结果</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target=1&amp;from=2</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">然后我们可以使用ES6新特性中的<span style = "color:yellow">模板字面量</span>拼接url</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">`https://api.example.com/data?<span class="subst">$&#123;dataParams&#125;</span>`</span>,&#123; <span class="comment">//注意这里是反引号 `` 代表模板字面量 可以使用插值 $&#123;&#125;</span></span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="title class_">Authorization</span>: <span class="string">&#x27;your_token&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">这样我们就成功传递了params参数</div><div style="color:#FFB7C5">fetch api在传递body参数时与axios大同小异，但是多了一<span style = "color:yellow">手动序列化</span>的流程, 这里我们借用一下上面提到的data对象来演示</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data) <span class="comment">// 手动序列化</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">这段代码中，我们就能很直观的看出与axios的区别，首先是请求头中'Content-Type'声明了请求体中传递的是JSON格式的数据，然后通过JS原生的JSON对象中的stringfy方法转化为json格式的字符串，这两个步骤就是上文提到的<span style = "color:yellow">手动序列化</span>，这样我们也就达成了传递body参数的目的</div><h2 id="处理返回"><a href="#处理返回" class="headerlink" title="处理返回"></a><span style="color:#FF6F91">处理返回</span></h2><div style="color:#FFB7C5">说完了发送请求，我们自然还要研究如何处理，不同于axios近乎傻瓜式的用法，fetch需要稍微复杂的处理</div><div style="color:#FFB7C5">fetch返回的是一个<span style = "color:yellow">promise对象</span>，最终会被解析为一个<span style = "color:yellow">response对象</span>，例如下面的代码</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fetchPromise = <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="title class_">Authorization</span>: <span class="string">&#x27;your_token&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fetchPromise.<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">response的结构为</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">response &#123;</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">ReadableStream</span>,</span><br><span class="line">    <span class="attr">bodyUsed</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">headers</span>: <span class="title class_">Headers</span> &#123;</span><br><span class="line">        <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json; charset=utf-8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;authorization&quot;</span>: <span class="string">&quot;your_token&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">ok</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">redirected</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">status</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">statusText</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;basic&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;https://api.example.com/data&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以显式的获取一些状态，比如说状态码和ok(是否访问成功), 以及访问头</div><div style="color:#FFB7C5">但是注意，<span style = "color:yellow">body是一个流，不能一次性获取所有内容</span>，这里涉及到另一个异步操作，下面给出具体的代码</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fetchPromise.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>(); <span class="comment">// 解析 JSON 数据 注意 这是一个异步操作 所以需要一个.then来读取</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data); <span class="comment">// 指向response.json()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">这样我们就可以读取后端返回的内容了,但是还得注意的是，<span style = "color:yellow">除非网络请求本身出现问题（无法连接到服务器等），fetch不会主动的抛出一个错误，即使是请求失败（404和500），也会返回一个成功的promise</span>，这里就需要我们自己来从处理error, 下面给出简单的代码示例</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fetchPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;网络响应错误，状态码：&#x27;</span> + response.<span class="property">status</span>); <span class="comment">//访问失败，抛出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;请求失败:&#x27;</span>, error); <span class="comment">// 打印错误信息</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">上述代码中，throw能让控制流转到最近的catch模块, 而new Error构造函数能创建一个错误对象，通过这种方式，我们可以成功的处理未捕捉到的请求错误问题</div><p><br><br></p><h3 id="综上即是fetch-api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案"><a href="#综上即是fetch-api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案" class="headerlink" title="综上即是fetch api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案"></a><div style="color:#FF6F91">综上即是fetch api的基础用法，但是实际的开发过程中，就算是高度封装的axios，我们也要进行进一步的封装以提升代码可读性，更别说是更加轻量化的fetch。下一篇博客，笔者将会以自己的项目为例来给出fetch的一套简易封装方案</div></h3><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a><div style="color:#FF6F91">未完待续…</div></h3><h3 id="了解了基础的fetch用法-下面我们来给出进阶的封装方法"><a href="#了解了基础的fetch用法-下面我们来给出进阶的封装方法" class="headerlink" title="了解了基础的fetch用法 下面我们来给出进阶的封装方法"></a><div style="color:#FF6F91">了解了基础的fetch用法 下面我们来给出进阶的封装方法</div></h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FetchOptions</span> &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">params</span>?: <span class="built_in">any</span>,</span><br><span class="line">    <span class="attr">body</span>?: <span class="built_in">any</span>,</span><br><span class="line">    <span class="title class_">Authorization</span>?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fetchInstance</span> = <span class="keyword">async</span> (<span class="params"><span class="attr">options</span>: <span class="title class_">FetchOptions</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; url, method, params, body, <span class="title class_">Authorization</span> &#125; = options;</span><br><span class="line">    <span class="keyword">const</span> response = &#123;</span><br><span class="line">        <span class="attr">status</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">errorMessage</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> completeURL = params ? url + <span class="string">&quot;?&quot;</span> + <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(params).<span class="title function_">toString</span>() : url;</span><br><span class="line">        <span class="keyword">const</span> resultPromise = <span class="keyword">await</span> <span class="title function_">fetch</span>(completeURL, &#123;</span><br><span class="line">            <span class="attr">method</span>: method,</span><br><span class="line">            <span class="attr">headers</span>: &#123;</span><br><span class="line">                ...(<span class="title class_">Authorization</span> ? &#123; <span class="title class_">Authorization</span>: <span class="title class_">Authorization</span> &#125; : &#123;&#125;),</span><br><span class="line">                <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...(body ? &#123; <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(body) &#125; : &#123;&#125;)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!resultPromise.<span class="property">ok</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;网络连接错误,状态码为&quot;</span> + resultPromise.<span class="property">status</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.<span class="property">status</span> = <span class="literal">true</span>;</span><br><span class="line">        response.<span class="property">data</span> = <span class="keyword">await</span> resultPromise.<span class="title function_">json</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="title class_">Error</span>) &#123;</span><br><span class="line">            response.<span class="property">errorMessage</span> = error.<span class="property">message</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        response</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; fetchInstance &#125;;</span><br></pre></td></tr></table></figure><h2 id="这是笔者封装的建议fetch接口-下面给出详细的解释"><a href="#这是笔者封装的建议fetch接口-下面给出详细的解释" class="headerlink" title="这是笔者封装的建议fetch接口 下面给出详细的解释"></a>这是笔者封装的建议fetch接口 下面给出详细的解释</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">FetchOptions</span> &#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">params</span>?: <span class="built_in">any</span>,</span><br><span class="line">    <span class="attr">body</span>?: <span class="built_in">any</span>,</span><br><span class="line">    <span class="title class_">Authorization</span>?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="这一段定义了传入参数的类型防止传入错误影响网络请求"><a href="#这一段定义了传入参数的类型防止传入错误影响网络请求" class="headerlink" title="这一段定义了传入参数的类型防止传入错误影响网络请求"></a>这一段定义了传入参数的类型防止传入错误影响网络请求</h3>]]></content>
    
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>样式隔离简介</title>
    <link href="/2024/10/18/style_isolation/"/>
    <url>/2024/10/18/style_isolation/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><span style="color:#FF6F91">简介</span></h2><div style="color:#FFB7C5">众所周知，css在web前端中具有样式控制、布局设计等重要作用。但是我们经常会遇到一个问题，就是修改一个组件的样式时会不自觉的影响到别的组件,比如说覆盖了上个已写好的背景颜色。这个问题叫做样式冲突。正因为这个问题，也就引出的这篇博客的主题-<span style='color:yellow;font-size:20px'>样式隔离</span>。下面笔者就对比简介css module、tailwindcss、vue css scoped的样式隔离方案</div><h2 id="CSS-MODULE的样式隔离方案"><a href="#CSS-MODULE的样式隔离方案" class="headerlink" title="CSS MODULE的样式隔离方案"></a><span style="color:#FF6F91">CSS MODULE的样式隔离方案</span></h2><div style="color:#FFB7C5">与一般的.css文件不同，.module.css在导入时会将类名封装在一个对象字面量里面，原先的类名作为对象的键，而值是经过修饰过的类名，以此达到样式隔离的目的</div><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">我们不妨来看这么一段代码</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">    color: white;</span><br><span class="line">    padding: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.title &#123;</span><br><span class="line">    font-size: 24px;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button &#123;</span><br><span class="line">    background-color: green;</span><br><span class="line">    color: white;</span><br><span class="line">    padding: 10px;</span><br><span class="line">    border: none;</span><br><span class="line">    border-radius: 5px;</span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> ./style.<span class="property">module</span>.<span class="property">css</span></span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">导入后, javascript会生成类似这样的对象</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styles = &#123;</span><br><span class="line">  <span class="attr">container</span>: <span class="string">&#x27;container__1a2b3&#x27;</span>, </span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;title__1a2b3&#x27;</span>, </span><br><span class="line">  <span class="attr">button</span>: <span class="string">&#x27;button__1a2b3&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">而对象的值作为新的类名，这样的方式让多处导入的同名类不会相互影响，以此达到了样式隔离的目的</div><h2 id="tailwindcss的样式隔离方案"><a href="#tailwindcss的样式隔离方案" class="headerlink" title="tailwindcss的样式隔离方案"></a><span style="color:#FF6F91">tailwindcss的样式隔离方案</span></h2><div style="color:#FFB7C5">与一般的css不同，tailwind使用了<span style="color:yellow">原子化CSS（Atomic CSS）</span>的设计理念来规避样式冲突问题，即一个类只包含一条CSS，或者说只干一件事情</div><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">我们不妨以这么一段简单的代码为例</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lg:text-xl&quot;</span>&gt;</span></span><br><span class="line">  Hello, World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">这段代码的意思是在屏幕较大的时候显示较大的字体,而打开tailwind生成的文件我们会发现, 这段代码被转化成了</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.lg\\:text-xl &#123;\n    font-size: 1.25rem;\n    line-height: 1.75rem;\n  &#125;</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">输出了一个css文件，并且在app.vue中导入 <br><br> 当类名变多时 如</div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;lg:text-xl p-5&quot;</span>&gt;</span></span><br><span class="line">  Hello, World!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">我们可以看到生成了这样一个文件</div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.p-5</span> &#123;\n  <span class="attribute">padding</span>: <span class="number">5px</span>;\n&#125;</span><br><span class="line"><span class="selector-class">.lg</span>\\:text-xl &#123;\n    <span class="attribute">font-size</span>: <span class="number">1.25rem</span>;\n    <span class="attribute">line-height</span>: <span class="number">1.75rem</span>;\n  &#125;</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">那么我们不难得出tailwind的工作原理:</div><ol style="color:yellow"><li>获取用户设置的class类，判断是否符合组件库规范<li>用空格拆分用户的class，将其转化为单独的类，每个类对应一条css<li>将每个类生成的css组合 输出一个有独特名字的css文件 包含一个名称与原class相同的css文件<li>将css文件导入组件，正常使用</ol><div style="color:#FFB7C5">正因如此，就算两个组件使用了相同的class类名，因为一个类名指向一个固定的css样式，有效的规避了样式冲突问题</div><h2 id="vue-css-scopped样式隔离方案"><a href="#vue-css-scopped样式隔离方案" class="headerlink" title="vue css scopped样式隔离方案"></a><span style="color:#FF6F91">vue css scopped样式隔离方案</span></h2><div style="color:#FFB7C5">在vue的style标签中添加scopped属性后，可以让组件的样式仅适用与该组件而不影响其他组件，以此来达到样式隔离的效果</div>  <h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a><span style="color:#FF6F91">原理</span></h3><div style="color:#FFB7C5">与css module类似，使用scopped属性后，vue会为每个css选择器添加一个独特的属性，确保不会被其他组件影响</div>  <div style="color:#FFB7C5">例如</div>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">.my-component &#123;</span><br><span class="line">    background-color: lightblue;</span><br><span class="line">    color: white;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><div style="color:#FFB7C5">.my-component 会被转换为 .my-component[data-v-xxxxxx], 也就不会被全局样式所影响</div><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a><span style="color:#FF6F91">作用</span></h2><div style="color:#FFB7C5">除了解决简述中的样式冲突问题, 样式隔离还有不少好处</div><h3 id="提高可维护性"><a href="#提高可维护性" class="headerlink" title="提高可维护性"></a><span style="color:#FF6F91">提高可维护性</span></h3><div style="color:#FFB7C5">传统的全局css样式往往是牵一发而动一身的，这给代码维护造成了很大的麻烦，而隔离了样式之后就能避免这一问题</div><h3 id="增强复用性"><a href="#增强复用性" class="headerlink" title="增强复用性"></a><span style="color:#FF6F91">增强复用性</span></h3><div style="color:#FFB7C5">复用是前端领域非常重要的一块，而样式隔离可以让复用组件的成本更低</div><h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a><span style="color:#FF6F91">团队协作</span></h3><div style="color:#FFB7C5">团队的不同成员可能会同时修改样式，样式隔离可以很好解决这个问题</div>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开博纪念</title>
    <link href="/2024/10/02/my_first_blog/"/>
    <url>/2024/10/02/my_first_blog/</url>
    
    <content type="html"><![CDATA[<p>我的第一篇博客</p><h2 id="关于窝"><a href="#关于窝" class="headerlink" title="关于窝"></a>关于窝</h2><h3 id="职业"><a href="#职业" class="headerlink" title="职业"></a>职业</h3><p>学生 就读于 zjut - 浙江工业大学</p><h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><p>HTML&#x2F;CSS JavaScript Vue.js lua</p><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><p>足球 DOTA2 魔兽世界 炉石传说 CS2</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
